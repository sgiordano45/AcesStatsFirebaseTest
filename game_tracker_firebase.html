<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Tracker - Mountainside Aces</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .drag-cursor {
            cursor: move;
        }
        .pointer-cursor {
            cursor: pointer;
        }
        svg text {
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- Firebase Integration Module -->
    <script type="module">
        import { getCurrentUser, onAuthChange, getUserProfile } from './firebase-auth.js';
        import { getCurrentSeason, getAllTeams, getSeasonPlayerStatsOptimized } from './firebase-data.js';
        import { getUpcomingTeamGames, getBattingOrder } from './firebase-roster.js';
        import { doc, setDoc, getDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { db } from './firebase-data.js';

        // Save game state to Firebase
        async function saveGameState(gameId, teamId, gameState, battingOrder) {
            try {
                const stateRef = doc(db, 'gameStates', `${gameId}_${teamId}`);
                await setDoc(stateRef, {
                    gameState,
                    battingOrder: battingOrder.map(p => p.id),
                    savedAt: serverTimestamp()
                });
                console.log('üíæ Game state saved');
            } catch (error) {
                console.error('Error saving game state:', error);
            }
        }

        // Load game state from Firebase
        async function loadGameState(gameId, teamId) {
            try {
                const stateRef = doc(db, 'gameStates', `${gameId}_${teamId}`);
                const stateDoc = await getDoc(stateRef);
                
                if (stateDoc.exists()) {
                    console.log('‚úÖ Found saved game state');
                    return stateDoc.data();
                }
                return null;
            } catch (error) {
                console.error('Error loading game state:', error);
                return null;
            }
        }

        // Delete game state from Firebase
        async function clearGameState(gameId, teamId) {
            try {
                const stateRef = doc(db, 'gameStates', `${gameId}_${teamId}`);
                await setDoc(stateRef, {
                    cleared: true,
                    clearedAt: serverTimestamp()
                });
                console.log('üóëÔ∏è Game state cleared');
            } catch (error) {
                console.error('Error clearing game state:', error);
            }
        }

        // Calculate batting stats from play history
        function calculateBattingStats(playHistory, battingOrder) {
            const playerStats = {};
            
            // Initialize stats for all players in the batting order
            battingOrder.forEach(player => {
                playerStats[player.id] = {
                    playerId: player.id,
                    playerName: player.name,
                    atBats: 0,
                    hits: 0,
                    singles: 0,
                    doubles: 0,
                    triples: 0,
                    homeRuns: 0,
                    walks: 0,
                    strikeouts: 0,
                    rbi: 0,
                    runs: 0,
                    battingAverage: 0,
                    onBasePercentage: 0,
                    sluggingPercentage: 0
                };
            });
            
            // Process each play
            playHistory.forEach(play => {
                const playerId = battingOrder.find(p => p.name === play.batter)?.id;
                if (!playerId || !playerStats[playerId]) return;
                
                const stats = playerStats[playerId];
                
                // Count at-bats (everything except walks and sac flies)
                if (play.playType !== 'walk' && play.playType !== 'sacfly') {
                    stats.atBats++;
                }
                
                // Count hits
                if (play.playType === 'single') {
                    stats.hits++;
                    stats.singles++;
                } else if (play.playType === 'double') {
                    stats.hits++;
                    stats.doubles++;
                } else if (play.playType === 'triple') {
                    stats.hits++;
                    stats.triples++;
                } else if (play.playType === 'homerun') {
                    stats.hits++;
                    stats.homeRuns++;
                } else if (play.playType === 'walk') {
                    stats.walks++;
                } else if (play.playType === 'strikeout') {
                    stats.strikeouts++;
                }
                
                // Count RBIs (runs scored on this play)
                if (play.runsScored > 0) {
                    stats.rbi += play.runsScored;
                }
            });
            
            // Calculate derived stats
            Object.values(playerStats).forEach(stats => {
                // Batting Average
                if (stats.atBats > 0) {
                    stats.battingAverage = stats.hits / stats.atBats;
                }
                
                // On-Base Percentage
                const plateAppearances = stats.atBats + stats.walks;
                if (plateAppearances > 0) {
                    stats.onBasePercentage = (stats.hits + stats.walks) / plateAppearances;
                }
                
                // Slugging Percentage
                if (stats.atBats > 0) {
                    const totalBases = stats.singles + (stats.doubles * 2) + (stats.triples * 3) + (stats.homeRuns * 4);
                    stats.sluggingPercentage = totalBases / stats.atBats;
                }
            });
            
            return Object.values(playerStats);
        }

        // Save game results to Firebase
        async function saveGameResults(gameId, teamId, seasonId, gameState, battingOrder, isHome, opponentName) {
            try {
                // Calculate batting stats
                const battingStats = calculateBattingStats(gameState.playHistory, battingOrder);
                
                // Save to gameResults collection
                const resultsRef = doc(db, 'gameResults', `${gameId}_${teamId}`);
                await setDoc(resultsRef, {
                    gameId,
                    teamId,
                    seasonId,
                    opponentName,
                    isHome,
                    finalScore: {
                        yourTeam: gameState.score.yourTeam,
                        opponent: gameState.score.opponent
                    },
                    innings: gameState.inning,
                    battingStats,
                    playByPlay: gameState.playHistory,
                    completedAt: serverTimestamp()
                });
                
                console.log('‚úÖ Game results saved with batting stats');
                return { success: true, battingStats };
            } catch (error) {
                console.error('Error saving game results:', error);
                return { success: false, error };
            }
        }

        // Make functions available globally for React component
        window.FirebaseGameTracker = {
            getCurrentUser,
            onAuthChange,
            getUserProfile,
            getCurrentSeason,
            getAllTeams,
            getSeasonPlayerStatsOptimized,
            getUpcomingTeamGames,
            getBattingOrder,
            saveGameState,
            loadGameState,
            clearGameState,
            saveGameResults
        };

        // Wait for auth state to be determined before signaling ready
        let authResolved = false;
        let currentAuthUser = null;
        
        onAuthChange((user) => {
            currentAuthUser = user;
            if (!authResolved) {
                authResolved = true;
                console.log('üîê Auth state resolved:', user ? user.displayName : 'Not signed in');
                window.firebaseReady = true;
                window.dispatchEvent(new Event('firebaseready'));
            }
        });
        
        // Store the current user for immediate access
        window.getCurrentFirebaseUser = () => currentAuthUser;
    </script>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Lucide React icons as inline SVG components
        const Undo2 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M9 14 4 9l5-5"/>
                <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
            </svg>
        );

        const Save = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
        );

        const PlayCircle = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <polygon points="10 8 16 12 10 16 10 8"/>
            </svg>
        );

        const AlertCircle = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
        );

        const PLAY_TYPES = [
            { label: '1B', value: 'single', bases: 1, isHit: true },
            { label: '2B', value: 'double', bases: 2, isHit: true },
            { label: '3B', value: 'triple', bases: 3, isHit: true },
            { label: 'HR', value: 'homerun', bases: 4, isHit: true },
            { label: 'BB', value: 'walk', bases: 1, isHit: false },
            { label: 'K', value: 'strikeout', bases: 0, isOut: true, noAdjust: true },
            { label: 'GO', value: 'groundout', bases: 0, isOut: true },
            { label: 'FO', value: 'flyout', bases: 0, isOut: true },
            { label: 'SF', value: 'sacfly', bases: 0, isOut: true },
            { label: 'FC', value: 'fielders_choice', bases: 0, isOut: false },
            { label: 'E', value: 'error', bases: 0, isOut: false },
            { label: 'DP', value: 'doubleplay', bases: 0, outs: 2 },
        ];

        function GameTracker() {
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [currentUser, setCurrentUser] = useState(null);
            const [currentSeason, setCurrentSeason] = useState(null);
            const [allTeams, setAllTeams] = useState([]);
            const [games, setGames] = useState([]);
            const [players, setPlayers] = useState([]);
            
            const [setupMode, setSetupMode] = useState(true);
            const [selectedTeam, setSelectedTeam] = useState('');
            const [selectedGame, setSelectedGame] = useState(null);
            const [isHome, setIsHome] = useState(false);
            const [lineupExists, setLineupExists] = useState(false);
            
            const [gameState, setGameState] = useState({
                inning: 1,
                outs: 0,
                bases: { first: null, second: null, third: null },
                score: { yourTeam: 0, opponent: 0 },
                currentBatter: 0,
                playHistory: [],
                gameActive: true,
                isYourTeamBatting: true
            });

            const [battingOrder, setBattingOrder] = useState([]);
            const [pendingPlay, setPendingPlay] = useState(null);
            const [tempBases, setTempBases] = useState(null);
            const [tempScore, setTempScore] = useState(0);
            const [tempOuts, setTempOuts] = useState(0);
            const [draggedRunner, setDraggedRunner] = useState(null);

            // Wait for Firebase to be ready, then load data
            useEffect(() => {
                const initializeApp = async () => {
                    if (window.firebaseReady) {
                        await loadInitialData();
                    } else {
                        window.addEventListener('firebaseready', loadInitialData);
                        return () => window.removeEventListener('firebaseready', loadInitialData);
                    }
                };
                initializeApp();
            }, []);

            // Load team-specific data when team changes
            useEffect(() => {
                if (selectedTeam && currentSeason) {
                    loadTeamData();
                }
            }, [selectedTeam, currentSeason]);

            // Auto-save game state whenever it changes
            useEffect(() => {
                if (!setupMode && selectedGame && selectedTeam && gameState.gameActive) {
                    const saveTimer = setTimeout(() => {
                        window.FirebaseGameTracker.saveGameState(
                            selectedGame.id,
                            selectedTeam,
                            gameState,
                            battingOrder
                        );
                    }, 1000);
                    
                    return () => clearTimeout(saveTimer);
                }
            }, [gameState, setupMode, selectedGame, selectedTeam, battingOrder]);

            const loadInitialData = async () => {
                try {
                    console.log('üìÑ Loading initial data from Firebase...');
                    
                    const user = window.getCurrentFirebaseUser ? window.getCurrentFirebaseUser() : null;
                    setCurrentUser(user);
                    
                    if (user) {
                        console.log('‚úÖ Signed in as:', user.displayName || user.email);
                        
                        try {
                            const profileResult = await window.FirebaseGameTracker.getUserProfile(user.uid);
                            if (profileResult.success && profileResult.data?.linkedTeam) {
                                console.log('‚úÖ Auto-selecting team:', profileResult.data.linkedTeam);
                                setSelectedTeam(profileResult.data.linkedTeam);
                            }
                        } catch (profileError) {
                            console.warn('Could not load user profile:', profileError);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è Not signed in');
                    }
                    
                    const seasonData = await window.FirebaseGameTracker.getCurrentSeason();
                    setCurrentSeason(seasonData);
                    console.log('‚úÖ Current season:', seasonData);
                    
                    const teams = await window.FirebaseGameTracker.getAllTeams();
                    const teamNames = teams.map(t => t.name || t.id).sort();
                    setAllTeams(teamNames);
                    console.log('‚úÖ Teams loaded:', teamNames.length);
                    
                    setLoading(false);
                } catch (err) {
                    console.error('‚ùå Error loading initial data:', err);
                    setError(err.message);
                    setLoading(false);
                }
            };

            const loadTeamData = async () => {
                try {
                    console.log('üìÑ Loading team data for:', selectedTeam);
                    
                    const seasonPlayers = await window.FirebaseGameTracker.getSeasonPlayerStatsOptimized(
                        currentSeason.id
                    );
                    
                    const teamPlayers = seasonPlayers.filter(p => 
                        p.team?.toLowerCase() === selectedTeam.toLowerCase() && !p.migrated
                    );
                    
                    console.log('üìä Team players:', teamPlayers.length);
                    
                    const formattedPlayersPromises = teamPlayers.map(async (player, index) => {
                        const name = player.name || player.playerName;
                        const nameParts = name.trim().split(' ');
                        const avatar = nameParts.length > 1
                            ? (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase()
                            : name.substring(0, 2).toUpperCase();
                        
                        let jerseyNum = player.number || (index + 1);
                        
                        // Try to get the player's profile for accurate jersey number
                        try {
                            const playerProfile = await window.FirebaseGameTracker.getUserProfile(player.playerId || player.id);
                            if (playerProfile.success && playerProfile.data?.number) {
                                jerseyNum = parseInt(playerProfile.data.number) || jerseyNum;
                            }
                        } catch (error) {
                            console.warn(`Could not load profile for ${name}:`, error);
                        }
                        
                        return {
                            id: player.playerId || player.id,
                            name,
                            number: jerseyNum.toString(),
                            position: player.position || 'IF/OF',
                            avatar,
                            battingAvg: player.battingAverage ? player.battingAverage.toFixed(3) : '.000'
                        };
                    });
                    
                    const formattedPlayers = await Promise.all(formattedPlayersPromises);
                    
                    setPlayers(formattedPlayers);
                    
                    const upcomingGames = await window.FirebaseGameTracker.getUpcomingTeamGames(
                        selectedTeam,
                        currentSeason.id
                    );
                    
                    const capitalizeTeamName = (name) => {
                        if (!name) return '';
                        return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                    };
                    
                    const formattedGames = upcomingGames.map(game => {
                        const gameDate = game.date?.seconds
                            ? new Date(game.date.seconds * 1000).toLocaleDateString()
                            : game.date;
                        
                        const teamLower = selectedTeam.toLowerCase();
                        const homeTeamLower = (game.homeTeam || game.homeTeamId || '').toLowerCase();
                        const isHome = homeTeamLower === teamLower;
                        
                        const homeTeamCapitalized = capitalizeTeamName(game.homeTeam || game.homeTeamId);
                        const awayTeamCapitalized = capitalizeTeamName(game.awayTeam || game.awayTeamId);
                        const opponent = isHome ? awayTeamCapitalized : homeTeamCapitalized;
                        
                        return {
                            id: game.id,
                            date: gameDate,
                            homeTeam: homeTeamCapitalized,
                            awayTeam: awayTeamCapitalized,
                            opponent,
                            isHome
                        };
                    });
                    
                    setGames(formattedGames);
                    console.log('‚úÖ Team data loaded:', formattedPlayers.length, 'players,', formattedGames.length, 'games');
                    
                } catch (error) {
                    console.error('‚ùå Error loading team data:', error);
                }
            };

            const handleTeamSelect = (team) => {
                setSelectedTeam(team);
                setSelectedGame(null);
                setLineupExists(false);
            };

            const handleGameSelect = async (game) => {
                setSelectedGame(game);
                const teamIsHome = game.homeTeam?.toLowerCase() === selectedTeam.toLowerCase();
                setIsHome(teamIsHome);
                
                try {
                    const battingOrderIds = await window.FirebaseGameTracker.getBattingOrder(
                        game.id,
                        selectedTeam
                    );
                    setLineupExists(battingOrderIds && battingOrderIds.length > 0);
                    
                    const savedState = await window.FirebaseGameTracker.loadGameState(
                        game.id,
                        selectedTeam
                    );
                    
                    if (savedState && !savedState.cleared && savedState.gameState) {
                        console.log('üìÇ Found game in progress');
                    }
                } catch (error) {
                    console.error('Error checking lineup:', error);
                    setLineupExists(false);
                }
            };

            const startGame = async () => {
                if (!selectedTeam || !selectedGame) return;
                
                const savedState = await window.FirebaseGameTracker.loadGameState(
                    selectedGame.id,
                    selectedTeam
                );
                
                if (savedState && !savedState.cleared && savedState.gameState) {
                    const resume = window.confirm(
                        'A game in progress was found. Do you want to resume where you left off?\n\n' +
                        `Inning: ${savedState.gameState.inning}\n` +
                        `Outs: ${savedState.gameState.outs}\n` +
                        `Score: ${savedState.gameState.score.yourTeam}\n` +
                        `Plays recorded: ${savedState.gameState.playHistory?.length || 0}\n\n` +
                        'Click OK to resume, or Cancel to start a new game.'
                    );
                    
                    if (resume) {
                        const savedBattingOrderIds = savedState.battingOrder || [];
                        const orderedPlayers = savedBattingOrderIds
                            .map(playerId => players.find(p => p.id === playerId))
                            .filter(p => p !== null && p !== undefined);
                        
                        if (orderedPlayers.length > 0) {
                            setBattingOrder(orderedPlayers);
                        } else {
                            setBattingOrder(players);
                        }
                        
                        setGameState(savedState.gameState);
                        setSetupMode(false);
                        console.log('‚úÖ Resumed game from saved state');
                        return;
                    } else {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam
                        );
                    }
                }
                
                try {
                    const battingOrderIds = await window.FirebaseGameTracker.getBattingOrder(
                        selectedGame.id,
                        selectedTeam
                    );
                    
                    if (battingOrderIds && battingOrderIds.length > 0) {
                        const orderedPlayers = battingOrderIds
                            .map(playerId => players.find(p => p.id === playerId))
                            .filter(p => p !== null && p !== undefined);
                        
                        if (orderedPlayers.length > 0) {
                            console.log('‚úÖ Loaded batting order from roster management:', orderedPlayers.length, 'players');
                            setBattingOrder(orderedPlayers);
                        } else {
                            console.log('‚ö†Ô∏è Could not map player IDs to players, using full roster');
                            setBattingOrder(players);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è No pre-set lineup found, using full roster');
                        setBattingOrder(players);
                    }
                } catch (error) {
                    console.error('Error loading batting order:', error);
                    console.log('Using full roster as fallback');
                    setBattingOrder(players);
                }
                
                setGameState({
                    inning: 1,
                    outs: 0,
                    bases: { first: null, second: null, third: null },
                    score: { yourTeam: 0, opponent: 0 },
                    currentBatter: 0,
                    playHistory: [],
                    gameActive: true,
                    isYourTeamBatting: !isHome
                });
                
                setSetupMode(false);
            };

            const currentBatter = battingOrder[gameState.currentBatter];
            const opponentName = selectedGame ? (isHome ? selectedGame.awayTeam : selectedGame.homeTeam) : 'Opponent';

            const initiatePlay = (playType) => {
                const play = PLAY_TYPES.find(p => p.value === playType);
                if (!play) return;

                if (play.noAdjust) {
                    const newState = { ...gameState };
                    newState.outs += 1;

                    const playRecord = {
                        inning: gameState.inning,
                        isYourTeam: gameState.isYourTeamBatting,
                        batter: currentBatter.name,
                        playType: play.value,
                        playLabel: play.label,
                        outsBefore: gameState.outs,
                        outsAfter: newState.outs,
                        basesBefore: { ...gameState.bases },
                        basesAfter: { ...gameState.bases },
                        runsScored: 0,
                        timestamp: Date.now()
                    };

                    newState.currentBatter = (newState.currentBatter + 1) % battingOrder.length;
                    newState.playHistory = [...gameState.playHistory, playRecord];
                    setGameState(newState);
                    return;
                }

                const newBases = { ...gameState.bases };
                let autoScore = 0;
                let autoOuts = 0;

                if (play.bases === 4) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    if (newBases.first) autoScore++;
                    autoScore++;
                    newBases.first = null;
                    newBases.second = null;
                    newBases.third = null;
                } else if (play.bases === 3) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    if (newBases.first) autoScore++;
                    newBases.third = currentBatter.name;
                    newBases.second = null;
                    newBases.first = null;
                } else if (play.bases === 2) {
                    if (newBases.third) autoScore++;
                    if (newBases.second) autoScore++;
                    newBases.third = newBases.first;
                    newBases.second = currentBatter.name;
                    newBases.first = null;
                } else if (play.bases === 1) {
                    const isWalk = play.value === 'walk';
                    
                    if (isWalk) {
                        if (newBases.first) {
                            if (newBases.second) {
                                if (newBases.third) {
                                    autoScore++;
                                    newBases.third = newBases.second;
                                    newBases.second = newBases.first;
                                    newBases.first = currentBatter.name;
                                } else {
                                    newBases.third = newBases.second;
                                    newBases.second = newBases.first;
                                    newBases.first = currentBatter.name;
                                }
                            } else {
                                const runnerOn3rd = newBases.third;
                                newBases.second = newBases.first;
                                newBases.first = currentBatter.name;
                                newBases.third = runnerOn3rd;
                            }
                        } else {
                            newBases.first = currentBatter.name;
                        }
                    } else {
                        const runnersToMove = [];
                        if (newBases.third) runnersToMove.push({ runner: newBases.third, from: 'third' });
                        if (newBases.second) runnersToMove.push({ runner: newBases.second, from: 'second' });
                        if (newBases.first) runnersToMove.push({ runner: newBases.first, from: 'first' });

                        newBases.first = currentBatter.name;
                        newBases.second = null;
                        newBases.third = null;

                        runnersToMove.forEach(({runner, from}) => {
                            if (from === 'third') {
                                autoScore++;
                            } else if (from === 'second') {
                                newBases.third = runner;
                            } else if (from === 'first') {
                                newBases.second = runner;
                            }
                        });
                    }
                } else if (play.isOut) {
                    autoOuts = 1;
                } else if (play.outs) {
                    autoOuts = play.outs;
                } else if (play.value === 'fielders_choice') {
                    newBases.first = currentBatter.name;
                } else if (play.value === 'error') {
                    newBases.first = currentBatter.name;
                }

                setTempBases(newBases);
                setTempScore(autoScore);
                setTempOuts(autoOuts);
                setPendingPlay({ play, type: playType });
            };

            const adjustRunner = (base, direction) => {
                const newBases = { ...tempBases };
                const runner = newBases[base];
                
                if (!runner) return;

                newBases[base] = null;

                if (direction === 'advance') {
                    if (base === 'first') {
                        newBases.second = runner;
                    } else if (base === 'second') {
                        newBases.third = runner;
                    } else if (base === 'third') {
                        setTempScore(tempScore + 1);
                    }
                } else if (direction === 'back') {
                    if (base === 'second') {
                        newBases.first = runner;
                    } else if (base === 'third') {
                        newBases.second = runner;
                    }
                }

                setTempBases(newBases);
            };

            const handleDragStart = (base) => {
                setDraggedRunner({ base, runner: tempBases[base] });
            };

            const handleDragOver = (e) => {
                e.preventDefault();
            };

            const handleDrop = (targetBase) => {
                if (!draggedRunner) return;

                const newBases = { ...tempBases };
                newBases[draggedRunner.base] = null;

                if (targetBase === 'home') {
                    setTempScore(tempScore + 1);
                } else {
                    newBases[targetBase] = draggedRunner.runner;
                }

                setTempBases(newBases);
                setDraggedRunner(null);
            };

            const removeRunner = (base) => {
                const newBases = { ...tempBases };
                newBases[base] = null;
                setTempBases(newBases);
                setTempOuts(tempOuts + 1);
            };

            const confirmPlay = () => {
                if (!pendingPlay) return;

                const newState = { ...gameState };
                const play = pendingPlay.play;

                newState.outs += tempOuts;

                const playRecord = {
                    inning: gameState.inning,
                    isYourTeam: gameState.isYourTeamBatting,
                    batter: currentBatter.name,
                    playType: play.value,
                    playLabel: play.label,
                    outsBefore: gameState.outs,
                    outsAfter: newState.outs,
                    basesBefore: { ...gameState.bases },
                    basesAfter: { ...tempBases },
                    runsScored: tempScore,
                    timestamp: Date.now()
                };

                newState.bases = tempBases;
                newState.score.yourTeam += tempScore;
                newState.currentBatter = (newState.currentBatter + 1) % battingOrder.length;
                newState.playHistory = [...gameState.playHistory, playRecord];

                setGameState(newState);
                setPendingPlay(null);
                setTempBases(null);
                setTempScore(0);
                setTempOuts(0);
            };

            const cancelPlay = () => {
                setPendingPlay(null);
                setTempBases(null);
                setTempScore(0);
                setTempOuts(0);
            };

            const advanceToNextHalfInning = () => {
                const newState = { ...gameState };
                newState.outs = 0;
                newState.bases = { first: null, second: null, third: null };
                
                if (newState.isYourTeamBatting) {
                    newState.isYourTeamBatting = false;
                    if (isHome) {
                        newState.inning += 1;
                    }
                } else {
                    newState.isYourTeamBatting = true;
                    if (!isHome) {
                        newState.inning += 1;
                    }
                }
                
                setGameState(newState);
            };

            const undoLastPlay = () => {
                if (gameState.playHistory.length === 0) return;

                const newHistory = [...gameState.playHistory];
                const lastPlay = newHistory.pop();

                const newState = {
                    ...gameState,
                    bases: { ...lastPlay.basesBefore },
                    outs: lastPlay.outsBefore,
                    score: {
                        ...gameState.score,
                        yourTeam: gameState.score.yourTeam - (lastPlay.runsScored || 0)
                    },
                    playHistory: newHistory
                };

                newState.currentBatter = (newState.currentBatter - 1 + battingOrder.length) % battingOrder.length;

                if (lastPlay.outsBefore >= 3 && gameState.outs === 0) {
                    if (gameState.isYourTeamBatting && gameState.inning > 1) {
                        newState.inning -= 1;
                        newState.isYourTeamBatting = false;
                    } else if (!gameState.isYourTeamBatting) {
                        newState.isYourTeamBatting = true;
                    }
                    newState.outs = lastPlay.outsBefore;
                }

                setGameState(newState);
            };

            const clearProgress = async () => {
                const confirmed = window.confirm(
                    '‚ö†Ô∏è Clear Game Progress?\n\n' +
                    'This will:\n' +
                    '- Delete all saved progress for this game\n' +
                    '- Reset to game setup screen\n' +
                    '- NOT save any batting stats\n\n' +
                    `Current Progress:\n` +
                    `- Inning: ${gameState.inning}\n` +
                    `- Score: ${gameState.score.yourTeam}-${gameState.score.opponent}\n` +
                    `- Plays: ${gameState.playHistory.length}\n\n` +
                    'Are you sure you want to clear all progress?'
                );
                
                if (confirmed) {
                    if (selectedGame && selectedTeam) {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam
                        );
                    }
                    
                    setSetupMode(true);
                    setGameState({
                        inning: 1,
                        outs: 0,
                        bases: { first: null, second: null, third: null },
                        score: { yourTeam: 0, opponent: 0 },
                        currentBatter: 0,
                        playHistory: [],
                        gameActive: true,
                        isYourTeamBatting: true
                    });
                    setPendingPlay(null);
                    setTempBases(null);
                    setTempScore(0);
                    setTempOuts(0);
                    
                    alert('‚úÖ Game progress cleared. You can start fresh or choose a different game.');
                }
            };

            const endGame = async () => {
                const confirmed = window.confirm(
                    'Are you sure you want to end the game?\n\n' +
                    `Final Score: ${selectedTeam} ${gameState.score.yourTeam} - ${opponentName} ${gameState.score.opponent}\n` +
                    `Plays Recorded: ${gameState.playHistory.length}\n\n` +
                    'This will save batting stats and clear the game tracker.'
                );
                
                if (confirmed) {
                    if (selectedGame && selectedTeam && currentSeason) {
                        const result = await window.FirebaseGameTracker.saveGameResults(
                            selectedGame.id,
                            selectedTeam,
                            currentSeason.id,
                            gameState,
                            battingOrder,
                            isHome,
                            opponentName
                        );
                        
                        if (result.success) {
                            alert(
                                '‚úÖ Game Complete!\n\n' +
                                'Batting stats have been saved:\n' +
                                `- ${result.battingStats.length} players tracked\n` +
                                `- ${gameState.playHistory.length} plays recorded\n` +
                                `- Final Score: ${gameState.score.yourTeam}-${gameState.score.opponent}`
                            );
                        }
                    }
                    
                    setGameState({ ...gameState, gameActive: false });
                    
                    if (selectedGame && selectedTeam) {
                        await window.FirebaseGameTracker.clearGameState(
                            selectedGame.id,
                            selectedTeam
                        );
                    }
                }
            };

            const displayBases = pendingPlay ? tempBases : gameState.bases;
            const displayScore = pendingPlay ? tempScore : 0;
            const inningOver = gameState.outs >= 3;

            if (loading) {
                return (
                    <div className="max-w-4xl mx-auto p-8 text-center">
                        <h1 className="text-4xl font-bold text-gray-900 mb-3">Loading Game Tracker...</h1>
                        <p className="text-lg text-gray-600">Connecting to Firebase...</p>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="max-w-4xl mx-auto p-8 text-center">
                        <h1 className="text-4xl font-bold text-red-600 mb-3">Error Loading Data</h1>
                        <p className="text-lg text-gray-600 mb-4">{error}</p>
                        <p className="text-sm text-gray-500">Please check your Firebase connection.</p>
                    </div>
                );
            }

            if (setupMode) {
                return (
                    <div className="max-w-4xl mx-auto p-8 font-sans">
                        <div className="text-center mb-10">
                            <h1 className="text-4xl font-bold text-gray-900 mb-3">
                                Game Tracker Setup
                            </h1>
                            <p className="text-lg text-gray-600">
                                {currentSeason ? `${currentSeason.year} ${currentSeason.season.charAt(0).toUpperCase() + currentSeason.season.slice(1)} Season` : 'Loading...'}
                            </p>
                            {!currentUser && (
                                <p className="text-sm text-amber-600 mt-2">
                                    ‚ÑπÔ∏è Not signed in - tracking will work but won't save to your account
                                </p>
                            )}
                        </div>

                        <div className="bg-white border-2 border-gray-200 rounded-xl p-6 mb-6">
                            <h2 className="text-2xl font-bold mb-4 text-gray-800">1. Select Your Team</h2>
                            <select 
                                value={selectedTeam}
                                onChange={(e) => handleTeamSelect(e.target.value)}
                                className="w-full p-4 text-lg border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none"
                            >
                                <option value="">Choose a team...</option>
                                {allTeams.map(team => (
                                    <option key={team} value={team}>{team}</option>
                                ))}
                            </select>
                        </div>

                        {selectedTeam && games.length > 0 && (
                            <div className="bg-white border-2 border-gray-200 rounded-xl p-6 mb-6">
                                <h2 className="text-2xl font-bold mb-4 text-gray-800">2. Select Game to Track</h2>
                                <div className="space-y-3">
                                    {games.map((game, idx) => (
                                        <button
                                            key={idx}
                                            onClick={() => handleGameSelect(game)}
                                            className={`w-full p-4 text-left rounded-lg border-2 transition-all ${
                                                selectedGame === game 
                                                    ? 'border-purple-500 bg-purple-50' 
                                                    : 'border-gray-300 hover:border-purple-300 bg-white'
                                            }`}
                                        >
                                            <div className="flex justify-between items-center">
                                                <div>
                                                    <span className="font-bold text-lg">{game.awayTeam}</span>
                                                    <span className="mx-3 text-gray-500">@</span>
                                                    <span className="font-bold text-lg">{game.homeTeam}</span>
                                                </div>
                                                <div className="text-gray-600">{game.date}</div>
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                {game.isHome ? 'Home Game' : 'Away Game'}
                                            </div>
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}

                        {selectedTeam && games.length === 0 && (
                            <div className="bg-amber-50 border-2 border-amber-400 rounded-xl p-6 mb-6">
                                <div className="flex items-center gap-3">
                                    <AlertCircle size={24} />
                                    <p className="text-amber-900">No upcoming games found for {selectedTeam}</p>
                                </div>
                            </div>
                        )}

                        {selectedTeam && selectedGame && (
                            <>
                                {lineupExists && (
                                    <div className="bg-green-50 border-2 border-green-400 rounded-xl p-4 mb-6">
                                        <div className="flex items-center gap-3">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                <polyline points="20 6 9 17 4 12"/>
                                            </svg>
                                            <p className="text-green-900 font-semibold">
                                                ‚úì Batting order set by captain - will be loaded automatically
                                            </p>
                                        </div>
                                    </div>
                                )}
                                <div className="text-center">
                                    <button
                                        onClick={startGame}
                                        className="px-12 py-5 text-xl font-bold bg-gradient-to-r from-purple-500 to-purple-700 text-white rounded-xl hover:from-purple-600 hover:to-purple-800 transition-all shadow-lg"
                                    >
                                        Start Game Tracker
                                    </button>
                                    <p className="mt-4 text-gray-600">
                                        Tracking: <strong>{selectedTeam}</strong> vs {opponentName}
                                        <br />
                                        <span className="text-sm">({isHome ? 'Home' : 'Away'} team)</span>
                                    </p>
                                </div>
                            </>
                        )}
                    </div>
                );
            }

            // Calculate live batting stats from current game
            const liveBattingStats = battingOrder.map(player => {
                const playerPlays = gameState.playHistory.filter(play => play.batter === player.name);
                
                let atBats = 0;
                let hits = 0;
                let runs = 0;
                let walks = 0;
                
                playerPlays.forEach(play => {
                    if (play.playType !== 'walk' && play.playType !== 'sacfly') {
                        atBats++;
                    }
                    if (['single', 'double', 'triple', 'homerun'].includes(play.playType)) {
                        hits++;
                    }
                    if (play.playType === 'walk') {
                        walks++;
                    }
                });
                
                // Count runs scored by this player
                gameState.playHistory.forEach(play => {
                    if (play.basesAfter.first !== play.basesBefore.first && play.basesBefore.first === player.name) {
                        // Player was on first and moved/scored
                    }
                    if (play.basesAfter.second !== play.basesBefore.second && play.basesBefore.second === player.name) {
                        // Player was on second and moved/scored
                    }
                    if (play.basesAfter.third !== play.basesBefore.third && play.basesBefore.third === player.name) {
                        // Player was on third and moved/scored
                    }
                    // Check if player scored (was on base before, not after, and runs were scored)
                    if (play.runsScored > 0) {
                        if (play.basesBefore.third === player.name && !play.basesAfter.third) runs++;
                        if (play.basesBefore.second === player.name && !play.basesAfter.second && !play.basesAfter.third) runs++;
                        if (play.basesBefore.first === player.name && !play.basesAfter.first && !play.basesAfter.second && !play.basesAfter.third) runs++;
                    }
                    // Home runs count as a run for the batter
                    if (play.batter === player.name && play.playType === 'homerun') {
                        runs++;
                    }
                });
                
                return {
                    name: player.name,
                    number: player.number,
                    atBats,
                    hits,
                    runs,
                    walks,
                    avg: atBats > 0 ? (hits / atBats).toFixed(3) : '.000'
                };
            });

            return (
                <div className="max-w-7xl mx-auto p-5 font-sans">
                    <div className="text-center mb-6">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">
                            Live Game Tracker
                        </h1>
                        <div className="text-lg text-gray-600">
                            {selectedTeam} vs {opponentName}
                        </div>
                        <div className="text-sm text-gray-500">
                            {selectedGame?.date} ‚Ä¢ {isHome ? 'Home' : 'Away'} Game
                        </div>
                    </div>

                    <div className="bg-gradient-to-br from-purple-500 to-purple-700 text-white p-5 rounded-xl mb-5 grid grid-cols-3 gap-4 text-center">
                        <div>
                            <div className="text-sm opacity-90">Inning</div>
                            <div className="text-2xl font-bold">
                                {(isHome && !gameState.isYourTeamBatting) || (!isHome && gameState.isYourTeamBatting) ? '‚ñ≤' : '‚ñº'} {gameState.inning}
                            </div>
                            <div className="text-xs opacity-75 mt-1">
                                {gameState.isYourTeamBatting ? `${selectedTeam} Batting` : `${opponentName} Batting`}
                            </div>
                        </div>
                        <div>
                            <div className="text-sm opacity-90">Outs</div>
                            <div className="text-2xl font-bold">{gameState.outs}</div>
                        </div>
                        <div>
                            <div className="text-sm opacity-90">{selectedTeam} Score</div>
                            <div className="text-2xl font-bold">
                                {gameState.score.yourTeam}
                            </div>
                        </div>
                    </div>

                    {inningOver && gameState.gameActive && !pendingPlay && (
                        <div className="bg-gradient-to-br from-amber-500 to-amber-600 text-white p-6 rounded-xl mb-5 text-center">
                            <div className="text-2xl font-bold mb-2">
                                3 Outs - Side Retired
                            </div>
                            {gameState.isYourTeamBatting ? (
                                <>
                                    <div className="text-base mb-2 opacity-95">
                                        {selectedTeam}'s half inning is complete
                                    </div>
                                    <div className="text-sm mb-5 opacity-90 italic">
                                        Opponent batting - click when {selectedTeam} is back at bat
                                    </div>
                                    <button
                                        onClick={advanceToNextHalfInning}
                                        className="px-10 py-4 text-lg font-bold border-none rounded-lg cursor-pointer bg-white text-amber-600 shadow-lg hover:shadow-xl transition-all"
                                    >
                                        {isHome ? `Top ${gameState.inning + 1} - ${opponentName} Batting` : `Bottom ${gameState.inning} - ${opponentName} Batting`}
                                    </button>
                                </>
                            ) : (
                                <>
                                    <div className="text-base mb-2 opacity-95">
                                        {opponentName}'s half inning is complete
                                    </div>
                                    <div className="text-sm mb-5 opacity-90 italic">
                                        Click below to start tracking {selectedTeam}'s at-bats
                                    </div>
                                    <button
                                        onClick={advanceToNextHalfInning}
                                        className="px-10 py-4 text-lg font-bold border-none rounded-lg cursor-pointer bg-white text-amber-600 shadow-lg hover:shadow-xl transition-all"
                                    >
                                        {isHome ? `Bottom ${gameState.inning} - ${selectedTeam} Batting` : `Top ${gameState.inning + 1} - ${selectedTeam} Batting`}
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                    {!gameState.isYourTeamBatting && !inningOver && (
                        <div className="bg-blue-50 border-2 border-blue-400 rounded-lg p-6 mb-5 text-center">
                            <div className="text-xl font-bold mb-2 text-blue-900">
                                {opponentName} is Batting
                            </div>
                            <div className="text-base text-blue-800 mb-3">
                                No tracking needed - wait for 3 outs
                            </div>
                            <button
                                onClick={advanceToNextHalfInning}
                                className="px-8 py-3 text-lg font-bold border-none rounded-lg cursor-pointer bg-purple-600 text-white hover:bg-purple-700 transition-colors shadow-lg inline-flex items-center gap-2"
                            >
                                <PlayCircle size={20} /> Back at Bat
                            </button>
                        </div>
                    )}

                    {pendingPlay && (
                        <div className="bg-amber-50 border-2 border-amber-400 rounded-lg p-4 mb-5 text-center">
                            <div className="font-bold mb-1 text-amber-900">
                                Adjust Base Runners
                            </div>
                            <div className="text-sm text-amber-800">
                                Use arrows ‚Ä¢ Drag runners to bases or home ‚Ä¢ Click X to mark runner out
                            </div>
                        </div>
                    )}

                    {gameState.isYourTeamBatting && (
                        <>
                            <div className="flex flex-col lg:flex-row gap-6 mb-8">
                                <div className={`relative w-full lg:max-w-lg bg-green-800 rounded-xl p-8 ${pendingPlay ? 'border-4 border-amber-400' : ''} ${inningOver && !pendingPlay ? 'opacity-50' : 'opacity-100'}`}>
                                <svg viewBox="0 0 400 400" className="w-full h-auto">
                                    <polygon 
                                        points="200,80 320,200 200,320 80,200" 
                                        fill="#8b4513"
                                        stroke="#fff"
                                        strokeWidth="3"
                                    />
                                    
                                    <circle 
                                        cx="200" 
                                        cy="320" 
                                        r="25" 
                                        fill={draggedRunner ? '#10b981' : '#fff'}
                                        onDragOver={handleDragOver}
                                        onDrop={() => handleDrop('home')}
                                        style={{ cursor: draggedRunner ? 'pointer' : 'default' }}
                                    />
                                    <text x="200" y="365" textAnchor="middle" fill="#fff" fontSize="14" fontWeight="bold">
                                        HOME
                                    </text>

                                    {['first', 'second', 'third'].map((base, idx) => {
                                        const positions = {
                                            first: { cx: 320, cy: 200, labelY: 165, arrowY: 240, arrow1X: 295, arrow2X: 345, removeY: 225, 
                                                    advanceArrow: '‚ñ≤', backArrow: '‚ñº' },
                                            second: { cx: 200, cy: 80, labelY: 45, arrowY: 120, arrow1X: 175, arrow2X: 225, removeY: 105,
                                                     advanceArrow: '‚óÄ', backArrow: '‚ñ∂' },
                                            third: { cx: 80, cy: 200, labelY: 165, arrowY: 240, arrow1X: 55, arrow2X: 105, removeY: 225,
                                                    advanceArrow: '‚ñº', backArrow: '‚ñ≤' }
                                        };
                                        const pos = positions[base];
                                        const baseLabel = base === 'first' ? '1B' : base === 'second' ? '2B' : '3B';

                                        return (
                                            <g key={base}>
                                                <circle 
                                                    cx={pos.cx} 
                                                    cy={pos.cy} 
                                                    r="32" 
                                                    fill={displayBases[base] ? '#fbbf24' : '#fff'} 
                                                    stroke="#000"
                                                    strokeWidth="2"
                                                    onDragOver={handleDragOver}
                                                    onDrop={() => handleDrop(base)}
                                                    style={{ cursor: draggedRunner ? 'pointer' : 'default' }}
                                                />
                                                <text x={pos.cx} y={pos.labelY} textAnchor="middle" fill="#fff" fontSize="12" fontWeight="bold">
                                                    {baseLabel}
                                                </text>
                                                {displayBases[base] && (
                                                    <g>
                                                        <text 
                                                            x={pos.cx} 
                                                            y={pos.cy + 5} 
                                                            textAnchor="middle" 
                                                            fill="#000" 
                                                            fontSize="11" 
                                                            fontWeight="bold"
                                                            style={{ cursor: pendingPlay ? 'move' : 'default' }}
                                                            draggable={pendingPlay}
                                                            onDragStart={() => handleDragStart(base)}
                                                        >
                                                            {displayBases[base].split(' ').pop()}
                                                        </text>
                                                        {pendingPlay && (
                                                            <>
                                                                <text 
                                                                    x={pos.arrow1X} y={pos.arrowY} 
                                                                    textAnchor="middle" 
                                                                    fill="#fff" 
                                                                    fontSize="18" 
                                                                    fontWeight="bold"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => adjustRunner(base, 'back')}
                                                                >
                                                                    {pos.backArrow}
                                                                </text>
                                                                <text 
                                                                    x={pos.arrow2X} y={pos.arrowY} 
                                                                    textAnchor="middle" 
                                                                    fill="#fff" 
                                                                    fontSize="18" 
                                                                    fontWeight="bold"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => adjustRunner(base, 'advance')}
                                                                >
                                                                    {pos.advanceArrow}
                                                                </text>
                                                                <circle
                                                                    cx={pos.cx}
                                                                    cy={pos.removeY}
                                                                    r="8"
                                                                    fill="#ef4444"
                                                                    style={{ cursor: 'pointer' }}
                                                                    onClick={() => removeRunner(base)}
                                                                />
                                                                <text
                                                                    x={pos.cx}
                                                                    y={pos.removeY + 4}
                                                                    textAnchor="middle"
                                                                    fill="white"
                                                                    fontSize="10"
                                                                    fontWeight="bold"
                                                                    style={{ pointerEvents: 'none' }}
                                                                >
                                                                    X
                                                                </text>
                                                            </>
                                                        )}
                                                    </g>
                                                )}
                                            </g>
                                        );
                                    })}
                                </svg>

                                {pendingPlay && (displayScore > 0 || tempOuts > 0) && (
                                    <div className="absolute bottom-3 left-1/2 -translate-x-1/2 flex gap-3 items-center">
                                        {displayScore > 0 && (
                                            <div className="bg-green-600 text-white px-4 py-2 rounded-lg font-bold">
                                                +{displayScore} Run{displayScore > 1 ? 's' : ''}
                                            </div>
                                        )}
                                        {tempOuts > 0 && (
                                            <div className="bg-red-500 text-white px-4 py-2 rounded-lg font-bold">
                                                +{tempOuts} Out{tempOuts > 1 ? 's' : ''}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            <div className="bg-white border border-gray-200 rounded-xl p-4 flex-shrink-0" style={{ width: '280px' }}>
                                <h3 className="text-lg font-bold mb-3 text-gray-800">Live Batting Stats</h3>
                                <div className="space-y-1 max-h-96 overflow-y-auto">
                                    {liveBattingStats.map((stat, idx) => {
                                        const isCurrentBatter = idx === gameState.currentBatter;
                                        return (
                                            <div 
                                                key={stat.name}
                                                className={`text-xs p-2 rounded ${isCurrentBatter ? 'bg-purple-100 border-2 border-purple-500 font-bold' : 'bg-gray-50'}`}
                                            >
                                                <div className="flex items-center gap-1 mb-1">
                                                    <span className="text-gray-500">#{stat.number}</span>
                                                    <span className="font-semibold text-gray-900 truncate">{stat.name.split(' ').pop()}</span>
                                                </div>
                                                <div className="grid grid-cols-4 gap-1 text-center">
                                                    <div>
                                                        <div className="text-gray-500">AB</div>
                                                        <div className="font-bold">{stat.atBats}</div>
                                                    </div>
                                                    <div>
                                                        <div className="text-gray-500">H</div>
                                                        <div className="font-bold">{stat.hits}</div>
                                                    </div>
                                                    <div>
                                                        <div className="text-gray-500">R</div>
                                                        <div className="font-bold">{stat.runs}</div>
                                                    </div>
                                                    <div>
                                                        <div className="text-gray-500">BB</div>
                                                        <div className="font-bold">{stat.walks}</div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>

                            {pendingPlay && (
                                <div className="flex gap-3 mb-5 justify-center">
                                    <button
                                        onClick={confirmPlay}
                                        className="px-8 py-4 text-lg font-bold border-none rounded-lg cursor-pointer bg-green-600 text-white hover:bg-green-700 transition-colors inline-flex items-center gap-2"
                                    >
                                        <PlayCircle size={20} /> Confirm Play
                                    </button>
                                    <button
                                        onClick={cancelPlay}
                                        className="px-8 py-4 text-lg font-bold border-2 border-red-500 rounded-lg cursor-pointer bg-white text-red-500 hover:bg-red-50 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            )}

                            <div className={`bg-gray-100 p-5 rounded-xl mb-5 text-center ${inningOver ? 'opacity-40' : 'opacity-100'}`}>
                                <div className="text-sm text-gray-600 mb-1">Now Batting</div>
                                <div className="text-2xl font-bold text-gray-900">
                                    #{currentBatter?.number} {currentBatter?.name}
                                </div>
                                <div className="text-base text-gray-600">{currentBatter?.position}</div>
                            </div>

                            {gameState.gameActive && !pendingPlay && (
                                <div className={`grid grid-cols-4 gap-3 mb-8 ${inningOver ? 'opacity-30 pointer-events-none' : ''}`}>
                                    {PLAY_TYPES.map(play => (
                                        <button
                                            key={play.value}
                                            onClick={() => initiatePlay(play.value)}
                                            disabled={inningOver}
                                            className={`p-4 text-base font-bold border-none rounded-lg cursor-pointer text-white transition-transform hover:scale-105 ${
                                                play.isHit ? 'bg-green-600 hover:bg-green-700' : 
                                                play.isOut ? 'bg-red-500 hover:bg-red-600' : 
                                                'bg-blue-500 hover:bg-blue-600'
                                            }`}
                                        >
                                            {play.label}
                                        </button>
                                    ))}
                                </div>
                            )}
                        </>
                    )}

                    {!pendingPlay && (
                        <div className="flex gap-3 mb-8 justify-center flex-wrap">
                            <button
                                onClick={undoLastPlay}
                                disabled={gameState.playHistory.length === 0}
                                className={`px-6 py-3 border-none rounded-lg inline-flex items-center gap-2 ${
                                    gameState.playHistory.length === 0 
                                        ? 'bg-gray-300 cursor-not-allowed opacity-50' 
                                        : 'bg-gray-600 cursor-pointer hover:bg-gray-700'
                                } text-white transition-colors`}
                            >
                                <Undo2 size={18} /> Undo Last Play
                            </button>
                            
                            {gameState.gameActive && (
                                <>
                                    <button
                                        onClick={endGame}
                                        className="px-6 py-3 border-none rounded-lg cursor-pointer bg-red-600 text-white hover:bg-red-700 transition-colors inline-flex items-center gap-2"
                                    >
                                        <Save size={18} /> End Game
                                    </button>
                                    
                                    <button
                                        onClick={clearProgress}
                                        className="px-6 py-3 border-none rounded-lg cursor-pointer bg-orange-600 text-white hover:bg-orange-700 transition-colors inline-flex items-center gap-2"
                                    >
                                        <AlertCircle size={18} /> Clear Progress
                                    </button>
                                </>
                            )}
                        </div>
                    )}

                    <div className="bg-white border border-gray-200 rounded-xl p-5">
                        <h2 className="text-xl font-bold mb-4">Play-by-Play ({selectedTeam} Only)</h2>
                        <div className="max-h-80 overflow-y-auto">
                            {gameState.playHistory.length === 0 ? (
                                <div className="text-center text-gray-400 py-5">
                                    No plays recorded yet
                                </div>
                            ) : (
                                gameState.playHistory.slice().reverse().map((play) => (
                                    <div 
                                        key={play.timestamp}
                                        className="p-3 border-b border-gray-100 flex justify-between items-center"
                                    >
                                        <div className="flex-1">
                                            <span className="font-bold text-purple-600">
                                                {play.isYourTeam ? '‚ñ≤' : '‚ñº'} {play.inning}
                                            </span>
                                            {' ‚Ä¢ '}
                                            <span className="font-bold">{play.batter}</span>
                                            {' - '}
                                            <span className={`px-2 py-1 rounded text-sm font-bold ${
                                                PLAY_TYPES.find(p => p.value === play.playType)?.isHit ? 'bg-green-100 text-green-800' : 
                                                PLAY_TYPES.find(p => p.value === play.playType)?.isOut ? 'bg-red-100 text-red-800' : 
                                                'bg-blue-100 text-blue-800'
                                            }`}>
                                                {play.playLabel}
                                            </span>
                                            {play.runsScored > 0 && (
                                                <span className="ml-2 text-green-600 font-bold">
                                                    +{play.runsScored} run{play.runsScored > 1 ? 's' : ''}
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GameTracker />);
    </script>
</body>
</html>