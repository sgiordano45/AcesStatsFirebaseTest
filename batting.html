<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mountainside Aces - Batting Statistics</title>
<meta name="theme-color" content="#2d5016">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="mobile-enhancements.css">
<link rel="stylesheet" href="nav-styles.css">
<style>
:root {
  --primary-color: #2d5016;
  --secondary-color: #1a6b4a;
  --accent-color: #ffd700;
  --card-bg: #ffffff;
  --text-dark: #2d3748;
  --text-light: #718096;
  --border-color: #e2e8f0;
  --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
  --shadow-lg: 0 12px 32px rgba(0,0,0,0.16);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
  min-height: 100vh;
  color: var(--text-dark);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,255,255,0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.3s ease;
}

.loading-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}

.softball-spinner::before {
  content: '⚾';
  font-size: 80px;
  animation: spin 1.5s ease-in-out infinite;
}

@keyframes spin {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

/* Header */
.page-header {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  padding: 4rem 2rem;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
  color: white;
  text-align: center;
}

.page-header::before {
  content: '';
  position: absolute;
  top: -50px;
  right: -50px;
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border-radius: 50%;
}

.page-header::after {
  content: '⚾';
  position: absolute;
  bottom: -30px;
  left: -30px;
  font-size: 200px;
  opacity: 0.05;
}

.page-header h1 {
  font-size: 3.5rem;
  font-weight: 800;
  margin-bottom: 1rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  position: relative;
  z-index: 1;
}

.page-header p {
  font-size: 1.3rem;
  font-weight: 300;
  opacity: 0.9;
  position: relative;
  z-index: 1;
}

/* Dashboard Container */
.page-container {
  max-width: 1400px;
  margin: 3rem auto;
  padding: 0 2rem;
}

/* Summary Section */
.summary {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  position: relative;
}

.summary::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 5px;
  background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  border-radius: 16px 16px 0 0;
}

.summary p {
  margin: 0 0 1rem 0;
  color: var(--text-dark);
  font-size: 1rem;
  line-height: 1.6;
}

.summary p:last-child {
  margin-bottom: 0;
}

#loadingIndicator {
  text-align: center;
  padding: 2rem;
}

#loadingIndicator p:first-child {
  font-size: 1.2rem;
  color: var(--primary-color);
  font-weight: 600;
}

#loadingIndicator p:last-child {
  color: var(--text-light);
  margin-top: 0.5rem;
  font-size: 0.9rem;
}

/* Filters and Navigation Section */
.filters-nav {
  background: var(--card-bg);
  border-radius: 16px;
  padding: 2rem;
  margin-bottom: 2rem;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  position: relative;
}

.filters-nav::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 5px;
  background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  border-radius: 16px 16px 0 0;
}

.filters-section {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  align-items: center;
  margin-bottom: 1.5rem;
}

.filters-section > div {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.filters-section label {
  font-weight: 600;
  color: var(--text-dark);
}

.filters-section select {
  padding: 0.6rem 1.2rem;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  background: white;
  color: var(--text-dark);
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.filters-section select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(45,80,22,0.1);
}

/* Navigation Buttons */
.nav-container {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.nav-link {
  padding: 0.8rem 1.5rem;
  border: 2px solid var(--primary-color);
  background: white;
  color: var(--primary-color);
  text-decoration: none;
  border-radius: 12px;
  font-weight: 600;
  font-size: 1rem;
  transition: all 0.3s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  position: relative;
  overflow: hidden;
  cursor: pointer;
}

.nav-link::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--primary-color);
  transform: translateX(-100%);
  transition: transform 0.3s ease;
  z-index: -1;
}

.nav-link:hover::before {
  transform: translateX(0);
}

.nav-link:hover {
  color: white;
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.nav-link.pitching {
  border-color: #11998e;
  color: #11998e;
}

.nav-link.pitching::before {
  background: #11998e;
}

.nav-link.active {
  background: var(--primary-color);
  color: white;
}

.nav-link.batting.active {
  background: var(--primary-color);
}

/* Table Container */
.table-container {
  background: var(--card-bg);
  border-radius: 16px;
  overflow: hidden;
  box-shadow: var(--shadow-sm);
  border: 1px solid var(--border-color);
  position: relative;
}

.table-container::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 5px;
  background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  z-index: 1;
}

.swipe-indicator {
  display: none;
  text-align: center;
  padding: 0.75rem;
  background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 100%);
  color: #856404;
  font-size: 0.9rem;
  font-weight: 600;
  border-bottom: 2px solid #ffc107;
}

table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  margin: 0;
}

thead {
  background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
  position: sticky;
  top: 0;
  z-index: 10;
}

th {
  padding: 1rem;
  text-align: center;
  color: white;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  transition: background 0.3s ease;
  border: none;
}

th:hover {
  background: rgba(255,255,255,0.1);
}

th.asc::after {
  content: " ▲";
  font-size: 0.8em;
  margin-left: 0.5rem;
}

th.desc::after {
  content: " ▼";
  font-size: 0.8em;
  margin-left: 0.5rem;
}

td {
  padding: 1rem;
  text-align: center;
  border-bottom: 1px solid var(--border-color);
  color: var(--text-dark);
}

tbody tr {
  transition: all 0.3s ease;
}

tbody tr:nth-child(even) {
  background-color: #f8f9fa;
}

tbody tr:hover {
  background: linear-gradient(90deg, rgba(45,80,22,0.05) 0%, rgba(26,107,74,0.05) 100%);
  transform: scale(1.005);
  box-shadow: var(--shadow-sm);
}

td a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 600;
  transition: color 0.3s ease;
}

td a:hover {
  color: var(--secondary-color);
  text-decoration: underline;
}


/* Mobile Responsive */
@media (max-width: 768px) {
  .page-header h1 {
    font-size: 2.5rem;
  }
  
  .page-header p {
    font-size: 1.1rem;
  }
  
  .page-container {
    padding: 0 1rem;
    margin: 2rem auto;
  }
  
  .summary, .filters-nav {
    padding: 1.5rem;
  }
  
  .filters-section {
    flex-direction: column;
    align-items: stretch;
    gap: 1rem;
  }
  
  .filters-section > div {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filters-section select {
    width: 100%;
  }
  
  .nav-container {
    flex-direction: column;
  }
  
  .nav-link {
    width: 100%;
    justify-content: center;
  }
  
  .swipe-indicator {
    display: block;
  }
  
  table {
    font-size: 0.85rem;
  }
  
  th, td {
    padding: 0.6rem 0.4rem;
  }
  
  .table-container {
    overflow-x: auto;
  }
  
  .mobile-nav-container {
    display: block;
  }
}

@media (max-width: 480px) {
  .page-header {
    padding: 3rem 1rem;
  }
  
  .page-header h1 {
    font-size: 2rem;
  }
  
  table {
    font-size: 0.75rem;
  }
  
  th, td {
    padding: 0.5rem 0.3rem;
  }
}
</style>
</head>
<body>
<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay">
  <div class="softball-spinner"></div>
</div>


<!-- Header -->
<div class="page-header">
  <h1>Mountainside Aces Batting Stats</h1>
  <p>Complete batting statistics and performance metrics for all players</p>
</div>

<!-- Main Content -->
<div class="page-container">
  <!-- Summary Section -->
  <div id="summary" class="summary">
    <div id="loadingIndicator" style="text-align: center; padding: 2rem;">
      <p style="font-size: 1.2rem; color: var(--primary-color);">⏳ Loading batting statistics...</p>
      <p style="color: var(--text-light); margin-top: 0.5rem;">Using optimized aggregated collection (fast!)</p>
    </div>
    <p id="totalsText" style="display: none;"></p>
    <p id="leadersText" style="display: none;"></p>
  </div>

  <!-- Filters and Navigation -->
  <div class="filters-nav">
    <div class="filters-section">
      <div>
        <label for="yearFilter">Year:</label>
        <select id="yearFilter">
          <option value="All">All Years</option>
        </select>
      </div>
      <div>
        <label for="seasonFilter">Season:</label>
        <select id="seasonFilter">
          <option value="All">All Seasons</option>
        </select>
      </div>
    </div>
  
  </div>

  <!-- Statistics Table -->
  <div class="table-container">
    <div class="swipe-indicator">← Swipe left/right to see all columns →</div>
    <table id="statsTable">
      <thead>
        <tr>
          <th data-field="name">Name</th>
          <th data-field="team">Team</th>
          <th data-field="year">Year</th>
          <th data-field="season">Season</th>
          <th data-field="games">Games</th>
          <th data-field="atBats">At Bats</th>
          <th data-field="hits">Hits</th>
          <th data-field="runs">Runs</th>
          <th data-field="walks">Walks</th>
          <th data-field="AcesWar">AcesBPI</th>
          <th data-field="BA">BA</th>
          <th data-field="OBP">OBP</th>
          <th data-field="Sub">Sub</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows generated dynamically -->
      </tbody>
    </table>
  </div>
</div>

<script src="team-colors.js"></script>
<script type="module">
  console.log('📄 Script started - checking Firebase imports...');
  
  // Import optimized functions and season helpers
  import {
    getAllPlayerStatsOptimized,
    seasonsObjectToArray
  } from './firebase-data.js';
  
  console.log('✅ Firebase imports successful!');

  // Global variables
  let allPlayerData = [];
  let currentSortField = null;
  let currentSortDirection = 'desc';

  // Helper function for capitalization
  const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";

function formatPlayerName(name) {
  if (!name) return "";
  
  // If name already has spaces, capitalize each word properly
  if (name.includes(' ')) {
    return name.split(' ')
      .map(word => {
        // Handle special cases like DelleDonne, McDonald, etc.
        if (word.toLowerCase() === 'delledonne') return 'DelleDonne';
        if (word.toLowerCase() === 'mcdonald') return 'McDonald';
        if (word.toLowerCase() === 'mccarthy') return 'McCarthy';
		if (word.toLowerCase() === 'lacasse') return 'LaCasse';
		if (word.toLowerCase() === 'mccabe') return 'McCabe';
		if (word.toLowerCase() === "o'grady") return "O'Grady";
		if (word.toLowerCase() === 'mcmahon') return 'McMahon';
		if (word.toLowerCase() === 'mccorkell') return 'McCorkell';
		if (word.toLowerCase() === 'denoble') return 'DeNoble';
		if (word.toLowerCase() === 'digiacomo') return 'DiGiacomo';
        // Add more special cases as needed
        
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }
  
  // If name has underscores, replace with spaces and capitalize
  if (name.includes('_')) {
    return name.split('_')
      .map(word => {
        // Handle special cases
        if (word.toLowerCase() === 'delledonne') return 'DelleDonne';
        if (word.toLowerCase() === 'mcdonald') return 'McDonald';
        if (word.toLowerCase() === 'mccarthy') return 'McCarthy';
        if (word.toLowerCase() === 'mccabe') return 'McCabe';
		if (word.toLowerCase() === 'lacasse') return 'LaCasse';
		        if (word.toLowerCase() === "o'grady") return "O'Grady";
		if (word.toLowerCase() === 'mcmahon') return 'McMahon';
				if (word.toLowerCase() === 'mccorkell') return 'McCorkell';
		if (word.toLowerCase() === 'denoble') return 'DeNoble';
		if (word.toLowerCase() === 'digiacomo') return 'DiGiacomo';
		
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }
  
  // Handle special cases for single words
  if (name.toLowerCase() === 'delledonne') return 'DelleDonne';
  if (name.toLowerCase() === 'mcdonald') return 'McDonald';
  if (name.toLowerCase() === 'mccarthy') return 'McCarthy';
  if (name.toLowerCase() === 'mccabe') return 'McCabe';
  if (name.toLowerCase() === 'lacasse') return 'LaCasse';
  if (name.toLowerCase() === "o'grady") return "O'Grady";
  if (name.toLowerCase() === 'mcmahon') return 'McMahon';
  		if (name.toLowerCase() === 'mccorkell') return 'McCorkell';
		if (name.toLowerCase() === 'denoble') return 'DeNoble';
		if (name.toLowerCase() === 'digiacomo') return 'DiGiacomo';
  
  
  // Otherwise just capitalize the single name
  return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
}

  // Load data using optimized aggregated collection with object-keyed seasons
  async function loadData() {
    const loadStartTime = performance.now();
    console.log('⚡ Loading batting data from aggregated collection (OPTIMIZED)...');
    console.time('Total Load Time');
    
    try {
      console.time('Fetch Aggregated Data');
      const players = await getAllPlayerStatsOptimized();
      console.timeEnd('Fetch Aggregated Data');
      console.log(`✅ Loaded ${players?.length || 0} players from aggregated collection`);
      
      if (!players || players.length === 0) {
        console.warn('No player data found');
        document.getElementById('totalsText').textContent = 'No player data available.';
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('totalsText').style.display = 'block';
        document.getElementById('loadingOverlay').classList.add('hidden');
        return;
      }
      
      // Process seasons from OBJECT format (not array)
      console.time('Process Data');
      const allStats = [];

      players.forEach(player => {
        // CRITICAL CHANGE: seasons is now an OBJECT with seasonId keys
        if (player.seasons && typeof player.seasons === 'object') {
          // Convert seasons object to array for processing
          const seasonsArray = seasonsObjectToArray(player);
          
          seasonsArray.forEach(season => {
            // Parse year and season from seasonId
            // Format: "2024-fall" or "2025-spring"
            let year = "";
            let seasonName = "";
            
            if (season.seasonId) {
              const parts = season.seasonId.split('-');
              if (parts.length >= 2) {
                year = parts[0];           // "2024"
                seasonName = parts[1];     // "fall"
              }
            }
            
            // Fallback: try to get year and season from the season object directly
            if (!year && season.year) year = season.year;
            if (!seasonName && season.season) seasonName = season.season;
            
            allStats.push({
              name: formatPlayerName(player.name || player.displayName || player.userId),
              team: capitalize(season.team || player.currentTeam || ""),
              year: year,
              season: capitalize(seasonName),
              games: Number(season.games) || 0,
              atBats: Number(season.atBats) || 0,
              hits: Number(season.hits) || 0,
              runs: Number(season.runs) || 0,
              walks: Number(season.walks) || 0,
              AcesWar: typeof season.acesBPI === 'number' ? season.acesBPI :
                       (season.acesBPI === "N/A" ? "N/A" : Number(season.acesBPI) || 0),
              BA: season.battingAverage || 0,
              OBP: season.onBasePercentage || 0,
              sub: season.sub || "No",
              id: player.userId || player.id || "",
              seasonId: season.seasonId || ""
            });
          });
        }
      });
      
      console.log(`✅ Processed ${allStats.length} season records from ${players.length} players`);
      allPlayerData = allStats;
      console.timeEnd('Process Data');
      
      // Hide loading indicator and show data
      const loadingIndicator = document.getElementById('loadingIndicator');
      const totalsText = document.getElementById('totalsText');
      const leadersText = document.getElementById('leadersText');
      
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      if (totalsText) totalsText.style.display = 'block';
      if (leadersText) leadersText.style.display = 'block';
      
      console.time('Render UI');
      populateFilters();
      filterAndDisplayStats();
      updateSummary();
      console.timeEnd('Render UI');
      
      const loadEndTime = performance.now();
      console.timeEnd('Total Load Time');
      console.log(`🎉 Page loaded in ${(loadEndTime - loadStartTime).toFixed(0)}ms`);
      
      // Hide loading overlay
      document.getElementById('loadingOverlay').classList.add('hidden');
      
    } catch (error) {
      console.error('❌ Error loading data:', error);
      const totalsEl = document.getElementById('totalsText');
      if (totalsEl) {
        totalsEl.textContent = 'Error loading data. Please refresh the page.';
        totalsEl.style.display = 'block';
      }
      const loadingIndicator = document.getElementById('loadingIndicator');
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      document.getElementById('loadingOverlay').classList.add('hidden');
    }
  }

  // Populate year and season filters
  function populateFilters() {
    const yearFilter = document.getElementById('yearFilter');
    const seasonFilter = document.getElementById('seasonFilter');
    
    if (!yearFilter || !seasonFilter) {
      console.error('❌ Filter elements not found');
      return;
    }
    
    const years = new Set();
    const seasons = new Set();
    
    allPlayerData.forEach(player => {
      if (player.year) years.add(player.year);
      if (player.season) seasons.add(player.season);
    });
    
    // Clear existing options (except "All")
    yearFilter.innerHTML = '<option value="All">All Years</option>';
    seasonFilter.innerHTML = '<option value="All">All Seasons</option>';
    
    // Add years to filter
    Array.from(years).sort((a, b) => b.localeCompare(a)).forEach(year => {
      const option = document.createElement('option');
      option.value = year;
      option.textContent = year;
      yearFilter.appendChild(option);
    });
    
    // Add seasons to filter
    Array.from(seasons).sort().forEach(season => {
      const option = document.createElement('option');
      option.value = season;
      option.textContent = season;
      seasonFilter.appendChild(option);
    });
    
    console.log(`✅ Found ${years.size} unique years and ${seasons.size} unique seasons`);
    
    // Add event listeners
    yearFilter.addEventListener('change', filterAndDisplayStats);
    seasonFilter.addEventListener('change', filterAndDisplayStats);
  }

  // Filter and display statistics
  function filterAndDisplayStats() {
    const yearFilter = document.getElementById('yearFilter').value;
    const seasonFilter = document.getElementById('seasonFilter').value;
    
    let filteredData = allPlayerData;
    
    // Apply filters
    if (yearFilter !== 'All') {
      filteredData = filteredData.filter(p => p.year === yearFilter);
    }
    if (seasonFilter !== 'All') {
      filteredData = filteredData.filter(p => p.season === seasonFilter);
    }
    
    console.log(`📊 Filtered to ${filteredData.length} records`);
    
    // Sort if a sort field is selected, otherwise default to year/season
    if (currentSortField) {
      sortData(filteredData, currentSortField, currentSortDirection);
    } else {
      // Default sort: most recent first (2025 Fall, 2025 Summer, 2024 Fall, etc.)
      sortData(filteredData, 'year', 'desc');
    }
    
    // Display the table
    displayTable(filteredData);
    updateSummary(filteredData);
  }

  // Display table
  function displayTable(data) {
    const tbody = document.querySelector('#statsTable tbody');
    tbody.innerHTML = '';
    
    if (data.length === 0) {
      const row = tbody.insertRow();
      const cell = row.insertCell();
      cell.colSpan = 13;
      cell.textContent = 'No data available for selected filters';
      cell.style.textAlign = 'center';
      cell.style.padding = '2rem';
      return;
    }
    
    data.forEach(player => {
      const row = tbody.insertRow();
      
      // Name (with link to player page)
      const nameCell = row.insertCell();
      const nameLink = document.createElement('a');
      nameLink.href = `player.html?id=${encodeURIComponent(player.playerId || player.id)}`;
      nameLink.textContent = player.name;
      nameCell.appendChild(nameLink);
      
      // Team (with link to team page)
      const teamCell = row.insertCell();
      const teamLink = document.createElement('a');
      teamLink.href = `team.html?team=${encodeURIComponent(player.team)}`;
      teamLink.textContent = player.team;
      teamCell.appendChild(teamLink);
      
      // Other fields
      row.insertCell().textContent = player.year;
      row.insertCell().textContent = player.season;
      row.insertCell().textContent = player.games;
      row.insertCell().textContent = player.atBats;
      row.insertCell().textContent = player.hits;
      row.insertCell().textContent = player.runs;
      row.insertCell().textContent = player.walks;
      row.insertCell().textContent = typeof player.AcesWar === 'number' ? player.AcesWar.toFixed(2) : player.AcesWar;
      row.insertCell().textContent = typeof player.BA === 'number' ? player.BA.toFixed(3) : player.BA;
      row.insertCell().textContent = typeof player.OBP === 'number' ? player.OBP.toFixed(3) : player.OBP;
      row.insertCell().textContent = player.sub;
    });
  }

  // Update summary statistics
  function updateSummary(data = allPlayerData) {
    const totalsText = document.getElementById('totalsText');
    const leadersText = document.getElementById('leadersText');
    
    if (data.length === 0) {
      totalsText.textContent = 'No data available';
      leadersText.textContent = '';
      return;
    }
    
    // Calculate totals
    const totalGames = data.reduce((sum, p) => sum + p.games, 0);
    const totalAtBats = data.reduce((sum, p) => sum + p.atBats, 0);
    const totalHits = data.reduce((sum, p) => sum + p.hits, 0);
    const totalRuns = data.reduce((sum, p) => sum + p.runs, 0);
    const totalWalks = data.reduce((sum, p) => sum + p.walks, 0);
    
    // COUNT UNIQUE PLAYERS instead of total records
    const uniquePlayers = new Set(data.map(p => p.name)).size;
    // HELPER FUNCTION to format numbers with commas
      const formatNumber = (num) => num.toLocaleString('en-US');
    
    totalsText.textContent = `${formatNumber(uniquePlayers)} unique players | ${formatNumber(totalGames)} total games | ${formatNumber(totalAtBats)} at bats | ${formatNumber(totalHits)} hits | ${formatNumber(totalRuns)} runs | ${formatNumber(totalWalks)} walks`;
      
    // Find all-time leaders (use all data, not just filtered)
    const allTimeData = allPlayerData;
    const qualifiedPlayers = allTimeData.filter(p => p.atBats >= 10);
    
    if (allTimeData.length > 0) {
      // Counting stats leaders
      const topGames = allTimeData.reduce((max, p) => p.games > max.games ? p : max);
      const topAtBats = allTimeData.reduce((max, p) => p.atBats > max.atBats ? p : max);
      const topHits = allTimeData.reduce((max, p) => p.hits > max.hits ? p : max);
      const topRuns = allTimeData.reduce((max, p) => p.runs > max.runs ? p : max);
      const topWalks = allTimeData.reduce((max, p) => p.walks > max.walks ? p : max);
      
      // Rate stats leaders (minimum 10 at bats)
      const topBA = qualifiedPlayers.reduce((max, p) => p.BA > max.BA ? p : max, {BA: 0});
      const topOBP = qualifiedPlayers.reduce((max, p) => p.OBP > max.OBP ? p : max, {OBP: 0});
      
      // AcesBPI leader
      const topAcesWar = allTimeData.filter(p => typeof p.AcesWar === 'number').reduce((max, p) => p.AcesWar > max.AcesWar ? p : max, {AcesWar: 0});
      
      leadersText.innerHTML = `All-Time Single Season Leaders — Games: ${topGames.name} (${topGames.games}) | At Bats: ${topAtBats.name} (${topAtBats.atBats}) | Hits: ${topHits.name} (${topHits.hits}) | Runs: ${topRuns.name} (${topRuns.runs}) | Walks: ${topWalks.name} (${topWalks.walks}) | BA: ${topBA.name} (${topBA.BA.toFixed(3)}) | OBP: ${topOBP.name} (${topOBP.OBP.toFixed(3)}) | AcesBPI: ${topAcesWar.name} (${topAcesWar.AcesWar.toFixed(2)})`;
    } else {
      leadersText.textContent = '';
    }
  }

  // Sort functionality
  function sortData(data, field, direction) {
    data.sort((a, b) => {
      // Always sort by year first, then season, then team (for default grouping)
      // unless a specific field is being sorted
      
      if (field === 'year' || field === 'season' || !field) {
        // First sort by year (descending - newest first)
        const yearA = parseInt(a.year) || 0;
        const yearB = parseInt(b.year) || 0;
        
        if (yearA !== yearB) {
          return direction === 'asc' ? yearA - yearB : yearB - yearA;
        }
        
        // Within same year, sort by season (Fall > Summer > Spring)
        const seasonOrder = { 'Fall': 3, 'Summer': 2, 'Spring': 1 };
        const seasonA = seasonOrder[a.season] || 0;
        const seasonB = seasonOrder[b.season] || 0;
        
        if (seasonA !== seasonB) {
          return direction === 'asc' ? seasonA - seasonB : seasonB - seasonA;
        }
        
        // Within same year and season, sort by team name alphabetically
        const teamA = String(a.team).toLowerCase();
        const teamB = String(b.team).toLowerCase();
        return teamA.localeCompare(teamB);
      }
      
      // If sorting by team field specifically
      if (field === 'team') {
        const teamA = String(a.team).toLowerCase();
        const teamB = String(b.team).toLowerCase();
        const teamCompare = teamA.localeCompare(teamB);
        
        if (teamCompare !== 0) {
          return direction === 'asc' ? teamCompare : -teamCompare;
        }
        
        // Within same team, still maintain year/season order
        const yearA = parseInt(a.year) || 0;
        const yearB = parseInt(b.year) || 0;
        if (yearA !== yearB) return yearB - yearA;
        
        const seasonOrder = { 'Fall': 3, 'Summer': 2, 'Spring': 1 };
        const seasonA = seasonOrder[a.season] || 0;
        const seasonB = seasonOrder[b.season] || 0;
        return seasonB - seasonA;
      }
      
      // Regular sorting for other fields
      let aVal = a[field];
      let bVal = b[field];
      
      // Handle numeric vs string comparison
      if (typeof aVal === 'number' && typeof bVal === 'number') {
        const numCompare = direction === 'asc' ? aVal - bVal : bVal - aVal;
        
        // If values are equal, fall back to year/season/team order
        if (numCompare === 0) {
          const yearA = parseInt(a.year) || 0;
          const yearB = parseInt(b.year) || 0;
          if (yearA !== yearB) return yearB - yearA;
          
          const seasonOrder = { 'Fall': 3, 'Summer': 2, 'Spring': 1 };
          const seasonA = seasonOrder[a.season] || 0;
          const seasonB = seasonOrder[b.season] || 0;
          if (seasonA !== seasonB) return seasonB - seasonA;
          
          const teamA = String(a.team).toLowerCase();
          const teamB = String(b.team).toLowerCase();
          return teamA.localeCompare(teamB);
        }
        
        return numCompare;
      } else {
        aVal = String(aVal).toLowerCase();
        bVal = String(bVal).toLowerCase();
        
        const strCompare = direction === 'asc' ? 
          (aVal < bVal ? -1 : aVal > bVal ? 1 : 0) :
          (aVal > bVal ? -1 : aVal < bVal ? 1 : 0);
        
        // If values are equal, fall back to year/season/team order
        if (strCompare === 0) {
          const yearA = parseInt(a.year) || 0;
          const yearB = parseInt(b.year) || 0;
          if (yearA !== yearB) return yearB - yearA;
          
          const seasonOrder = { 'Fall': 3, 'Summer': 2, 'Spring': 1 };
          const seasonA = seasonOrder[a.season] || 0;
          const seasonB = seasonOrder[b.season] || 0;
          if (seasonA !== seasonB) return seasonB - seasonA;
          
          const teamA = String(a.team).toLowerCase();
          const teamB = String(b.team).toLowerCase();
          return teamA.localeCompare(teamB);
        }
        
        return strCompare;
      }
    });
  }

  // Add click handlers to table headers
  function initializeSorting() {
    document.querySelectorAll('#statsTable th[data-field]').forEach(th => {
      th.addEventListener('click', () => {
        const field = th.dataset.field;
        
        // Toggle direction if same field, otherwise default to desc
        if (currentSortField === field) {
          currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          currentSortField = field;
          currentSortDirection = 'desc';
        }
        
        // Update header classes
        document.querySelectorAll('#statsTable th').forEach(h => {
          h.classList.remove('asc', 'desc');
        });
        th.classList.add(currentSortDirection);
        
        // Re-filter and display
        filterAndDisplayStats();
      });
    });
  }

  // Initialize page when DOM is ready
  function initPage() {
    console.log('📄 Initializing page...');
    initializeSorting();
    loadData();
  }
  
  // Wait for DOM to be fully ready
  if (document.readyState === 'loading') {
    console.log('⏳ Waiting for DOM to load...');
    document.addEventListener('DOMContentLoaded', initPage);
  } else {
    // DOM is already loaded
    console.log('✅ DOM already loaded');
    initPage();
  }
</script>
<script type="module">
  import { NavigationComponent } from './nav-component.js';
  // Navigation auto-initializes on load!
</script>
<script src="mobile-enhancements.js"></script>
</body>
</html>
